{"version":3,"file":"bc08dc6e.js","sources":["../../../node_modules/@shopify/hydrogen/dist/esnext/foundation/useServerProps/use-server-props.js","../../../node_modules/@shopify/hydrogen/dist/esnext/foundation/Router/BrowserRouter.client.js"],"sourcesContent":["import { useContext } from 'react';\nimport { ServerPropsContext, } from '../ServerPropsProvider/ServerPropsProvider';\n/**\n * The `useServerProps` hook allows you to manage the [server props](https://shopify.dev/custom-storefronts/hydrogen/framework/server-props) passed to your server components when using Hydrogen as a React Server Component framework. The server props get cleared when you navigate from one route to another.\n *\n * ## Return value\n *\n * The `useServerProps` hook returns an object with the following keys:\n *\n * | Key              | Description                                                                            |\n * | ---------------- | -------------------------------------------------------------------------------------- |\n * | `serverProps`    | The current server props.                                                              |\n * | `setServerProps` | A function used to modify server props.                                                |\n * | `pending`        | Whether a [transition is pending](https://github.com/reactwg/react-18/discussions/41). |\n *\n */\nexport function useServerProps() {\n    const internalServerPropsContext = useContext(ServerPropsContext);\n    if (!internalServerPropsContext) {\n        return {};\n    }\n    return {\n        serverProps: internalServerPropsContext.serverProps,\n        setServerProps: internalServerPropsContext.setServerProps,\n        pending: internalServerPropsContext.pending,\n    };\n}\n/**\n * Internal-only hook to manage server state, including to set location server state\n * @internal\n */\nexport function useInternalServerProps() {\n    var _a;\n    return ((_a = useContext(ServerPropsContext)) !== null && _a !== void 0 ? _a : {});\n}\n","import { createBrowserHistory } from 'history';\nimport React, { createContext, useContext, useMemo, useState, useEffect, useLayoutEffect, useCallback, } from 'react';\nimport { META_ENV_SSR } from '../ssr-interop';\nimport { useInternalServerProps } from '../useServerProps/use-server-props';\nexport const RouterContext = createContext({});\nlet isFirstLoad = true;\nconst positions = {};\nexport const BrowserRouter = ({ history: pHistory, children, }) => {\n    if (META_ENV_SSR)\n        return React.createElement(React.Fragment, null, children);\n    /* eslint-disable react-hooks/rules-of-hooks */\n    const history = useMemo(() => pHistory || createBrowserHistory(), [pHistory]);\n    const [location, setLocation] = useState(history.location);\n    const [locationChanged, setLocationChanged] = useState(false);\n    const { pending, locationServerProps, setLocationServerProps } = useInternalServerProps();\n    useScrollRestoration({\n        location,\n        pending,\n        serverProps: locationServerProps,\n        locationChanged,\n        onFinishNavigating: () => setLocationChanged(false),\n    });\n    useLayoutEffect(() => {\n        const unlisten = history.listen(({ location: newLocation }) => {\n            positions[location.key] = window.scrollY;\n            setLocationServerProps({\n                pathname: newLocation.pathname,\n                search: newLocation.search,\n            });\n            setLocation(newLocation);\n            setLocationChanged(true);\n        });\n        return () => unlisten();\n    }, [\n        history,\n        location,\n        setLocationChanged,\n        setLocation,\n        setLocationServerProps,\n    ]);\n    /* eslint-enable react-hooks/rules-of-hooks */\n    return (React.createElement(RouterContext.Provider, { value: {\n            history,\n            location,\n        } }, children));\n};\nexport function useRouter() {\n    const router = useContext(RouterContext);\n    if (!router && META_ENV_SSR) {\n        throw new Error('useRouter must be used within a <Router> component');\n    }\n    return router;\n}\nexport function useLocation() {\n    return useRouter().location;\n}\n/**\n * Run a callback before browser unload.\n */\nfunction useBeforeUnload(callback) {\n    React.useEffect(() => {\n        window.addEventListener('beforeunload', callback);\n        return () => {\n            window.removeEventListener('beforeunload', callback);\n        };\n    }, [callback]);\n}\nfunction useScrollRestoration({ location, pending, serverProps, locationChanged, onFinishNavigating, }) {\n    /**\n     * Browsers have an API for scroll restoration. We wait for the page to load first,\n     * in case the browser is able to restore scroll position automatically, and then\n     * set it to manual mode.\n     */\n    useEffect(() => {\n        window.history.scrollRestoration = 'manual';\n    }, []);\n    /**\n     * If the page is reloading, allow the browser to handle its own scroll restoration.\n     */\n    useBeforeUnload(useCallback(() => {\n        window.history.scrollRestoration = 'auto';\n    }, []));\n    useLayoutEffect(() => {\n        // The app has just loaded\n        if (isFirstLoad || !locationChanged) {\n            isFirstLoad = false;\n            return;\n        }\n        const position = positions[location.key];\n        /**\n         * When serverState gets updated, `pending` is true while the fetch is in progress.\n         * When that resolves, the serverState is updated. We should wait until the internal\n         * location pointer and serverState match, and pending is false, to do any scrolling.\n         */\n        const finishedNavigating = !pending &&\n            location.pathname === serverProps.pathname &&\n            location.search === serverProps.search;\n        if (!finishedNavigating) {\n            return;\n        }\n        // If there is a location hash, scroll to it\n        if (location.hash) {\n            const element = document.querySelector(location.hash);\n            if (element) {\n                element.scrollIntoView();\n                onFinishNavigating();\n                return;\n            }\n        }\n        // If we have a matching position, scroll to it\n        if (position) {\n            window.scrollTo(0, position);\n            onFinishNavigating();\n            return;\n        }\n        // Scroll to the top of new pages\n        window.scrollTo(0, 0);\n        onFinishNavigating();\n    }, [\n        location.pathname,\n        location.search,\n        location.hash,\n        location.key,\n        pending,\n        serverProps.pathname,\n        serverProps.search,\n        locationChanged,\n        onFinishNavigating,\n    ]);\n}\n"],"names":["useContext","RouterContext","createContext","isFirstLoad","positions","BrowserRouter","history","pHistory","children","useMemo","createBrowserHistory","location","setLocation","useState","locationChanged","setLocationChanged","pending","locationServerProps","setLocationServerProps","useInternalServerProps","useScrollRestoration","serverProps","onFinishNavigating","useLayoutEffect","unlisten","listen","newLocation","key","window","scrollY","pathname","search","_jsx","router","META_ENV_SSR","Error","useRouter","callback","React","useEffect","addEventListener","removeEventListener","scrollRestoration","useBeforeUnload","useCallback","position","hash","element","document","querySelector","scrollIntoView","scrollTo"],"mappings":"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"}